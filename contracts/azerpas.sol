// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/*
 * Based on the excellent post by SVS (@woof) on Medium
 * https://medium.com/@svswoof/mitigating-gas-wars-bots-and-network-congestion-for-ethereum-nft-projects-6cdba15b91a4
*/

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
// So we can verify that a message was signed by the holder of the private keys of a given address, in 
// our case an address belonging to our backend
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

contract Azerpas is ERC721Enumerable, Ownable {
    using Strings for uint256;
    using ECDSA for bytes32;

    uint256 public constant DISTRIBUTED_TO_FNF = 111;
    uint256 public constant DISTRIBUTED_TO_PRIVATE = 1000;
    uint256 public constant DISTRIBUTED_TO_PUBLIC = 10000;
    uint256 public constant TOTAL_SUPPLY = DISTRIBUTED_TO_FNF + DISTRIBUTED_TO_PRIVATE + DISTRIBUTED_TO_PUBLIC;
    uint256 public constant PRICE = 0.05 ether;
    uint256 public constant MAX_PER_MINT = 5;

    mapping(string => bool) private _usedNonces;
    mapping(address => bool) public presalerList;
    mapping(address => uint256) public presalerListPurchases;

    // Define the URI smart-contract metadata URI
    /// @dev see https://docs.opensea.io/docs/contract-level-metadata
    string private _contractURI;

    //  Define the base URI for the tokens metadata
    // e.g: https://azerpas.com/MyNftProject/metadata (we will use one for our reveal)
    // or: ipfs://bafybeic26wp7ck2bsjhjm5pcdigxqebnthqrmugsygxj5fov2r2qwhxyqu (the real one will be the IPFS one)
    // Then a token metadata complete URI will look like this: https://azerpas.com/api/metadata/1
    // or: ipfs://bafybeic26wp7ck2bsjhjm5pcdigxqebnthqrmugsygxj5fov2r2qwhxyqu/1
    string private _tokenBaseURI = "https://azerpas.com/api/metadata/";

    // We can setup a few different addresses so the smart-contract split the total balance
    // in the withdraw method, we will split the gains between the artist, the dev, the owner, etc...
    address private _artistAddress = 0xDf56443C80C0f08bd766da095F68bbD2c45F2cb4;
    address private _signerAddress = 0x5260818d61ff27B7d0db3A96310246C041F7191e;

    // The smart-contract proof that can be used to check if any data has been modified
    // proof is an hash of all the tokens metadata
    /// @dev see this post https://medium.com/coinmonks/the-elegance-of-the-nft-provenance-hash-solution-823b39f99473
    /// or the excellent BAYC mechanism https://boredapeyachtclub.com/#/provenance
    string public proof;
    uint256 public giftedAmount;
    uint256 public publicAmountMinted;
    uint256 public privateAmountMinted;
    uint256 public presalePurchaseLimit = 2;
    bool public presaleLive;
    bool public saleLive;
    bool public locked;

    constructor() ERC721("Azerpas", "azer") { }

    modifier notLocked {
        require(!locked, "Contract metadata methods are locked");
        _;
    }
    
    /// Add pack of address to the "pre-sale" list
    /// @param entries a list of address
    function addToPresaleList(address[] calldata entries) external onlyOwner {
        for(uint256 i = 0; i < entries.length; i++) {
            address entry = entries[i];
            require(entry != address(0), "NULL_ADDRESS");
            require(!presalerList[entry], "DUPLICATE_ENTRY");

            presalerList[entry] = true;
        }   
    }

    /// Remove pack of address to the "pre-sale" list
    /// @param entries a list of address
    function removeFromPresaleList(address[] calldata entries) external onlyOwner {
        for(uint256 i = 0; i < entries.length; i++) {
            address entry = entries[i];
            require(entry != address(0), "NULL_ADDRESS");
            
            presalerList[entry] = false;
        }
    }

    /// This function hashes the same values as the server-side API
    /// @param sender who sends the message to our smart-contract
    /// @param qty the quantity of NFT to mint
    /// @param nonce a randomly generated string with a length of 8
    function hashTransaction(address sender, uint256 qty, string memory nonce) private pure returns(bytes32) {
          bytes32 hash = keccak256(abi.encodePacked(
            "\x19Ethereum Signed Message:\n32",
            keccak256(abi.encodePacked(sender, qty, nonce)))
          );
          return hash;
    }

    /// Check if the current _signerAddress is the same as the one given in the hash by the server-side API
    /// @param hash contains the ABI encoded user address, the quantity of NFT to mint and nonce - a random string of 8 chars
    /// @param signature signature generated by the backend from a private key
    function matchAddresSigner(bytes32 hash, bytes memory signature) private view returns(bool) {
        return _signerAddress == hash.recover(signature);
    }

    /// public minting function
    /// @param hash contains the ABI encoded user address, the quantity of NFT to mint and nonce - a random string of 8 chars
    /// @param signature signature generated by the backend from a private key
    /// @param nonce a randomly generated string with a length of 8
    /// @param tokenQuantity the quantity of NFT to mint
    function buy(bytes32 hash, bytes memory signature, string memory nonce, uint256 tokenQuantity) external payable {
        require(saleLive, "SALE_CLOSED");
        require(!presaleLive, "ONLY_PRESALE");
        // Check if the address signer is the same as the _signerAddress, preventing direct minting.
        require(matchAddresSigner(hash, signature), "DIRECT_MINT_DISALLOWED");
        // This is required to prevent someone from re-using the same signature and hash combination to mint again. 
        require(!_usedNonces[nonce], "HASH_USED");
        // Verify if the keccak256 hash matches the hash generated by the hashTransaction function
        require(hashTransaction(msg.sender, tokenQuantity, nonce) == hash, "HASH_FAIL");
        // Out of stock check
        require(totalSupply() < TOTAL_SUPPLY, "OUT_OF_STOCK");
        require(publicAmountMinted + tokenQuantity <= DISTRIBUTED_TO_PUBLIC, "EXCEED_PUBLIC");
        require(tokenQuantity <= MAX_PER_MINT, "EXCEED_MAX");
        require(PRICE * tokenQuantity <= msg.value, "INSUFFICIENT_ETH");
        
        for(uint256 i = 0; i < tokenQuantity; i++) {
            publicAmountMinted++;
            _safeMint(msg.sender, totalSupply() + 1);
        }
        
        // Add the nonce to the list of already used nonce
        _usedNonces[nonce] = true;
    }

    /// presale minting function
    /// @param tokenQuantity the quantity of NFT to mint
    function presaleBuy(uint256 tokenQuantity) external payable {
        require(!saleLive && presaleLive, "PRESALE_CLOSED");
        require(presalerList[msg.sender], "NOT_QUALIFIED");
        require(totalSupply() < TOTAL_SUPPLY, "OUT_OF_STOCK");
        require(privateAmountMinted + tokenQuantity <= DISTRIBUTED_TO_PRIVATE, "EXCEED_PRIVATE");
        require(presalerListPurchases[msg.sender] + tokenQuantity <= presalePurchaseLimit, "EXCEED_ALLOC");
        require(PRICE * tokenQuantity <= msg.value, "INSUFFICIENT_ETH");
        
        for (uint256 i = 0; i < tokenQuantity; i++) {
            privateAmountMinted++;
            presalerListPurchases[msg.sender]++;
            _safeMint(msg.sender, totalSupply() + 1);
        }
    }

    /// gift minting function
    /// @param receivers a list of address
    function gift(address[] calldata receivers) external onlyOwner {
        require(totalSupply() + receivers.length <= TOTAL_SUPPLY, "MAX_MINT");
        require(giftedAmount + receivers.length <= DISTRIBUTED_TO_FNF, "EXCEED_RECEIVERS");
        
        for (uint256 i = 0; i < receivers.length; i++) {
            giftedAmount++;
            _safeMint(receivers[i], totalSupply() + 1);
        }
    }

    /// withdraw mint gains to owner address
    /// @dev you can add some more receivers (artist, dev, marketing...) as variables above
    function withdraw() external onlyOwner {
        // payable(_artistAddress).transfer(address(this).balance * 2 / 5);
        payable(msg.sender).transfer(address(this).balance);
    }

    /// check if addr is in the pre-sale list
    /// @param addr to be checked against
    function isPresaler(address addr) external view returns (bool) {
        return presalerList[addr];
    }
    
    /// purchase count for an addr in the pre-sale list
    /// @param addr to be checked against
    function presalePurchasedCount(address addr) external view returns (uint256) {
        return presalerListPurchases[addr];
    }

    /// Enable pre-sale, public sale, hash, signer address...
    function lockMetadata() external onlyOwner {
        locked = true;
    }
    
    function togglePresaleStatus() external onlyOwner {
        presaleLive = !presaleLive;
    }
    
    function toggleSaleStatus() external onlyOwner {
        saleLive = !saleLive;
    }
    
    function setSignerAddress(address addr) external onlyOwner {
        _signerAddress = addr;
    }
    
    /// Set the smart-contract proof as an hash of all NFT metadata hashes
    /// @param hash of all NFTs metadata hashes
    function setProvenanceHash(string calldata hash) external onlyOwner notLocked {
        proof = hash;
    }
    
    /// Set smart-contract metadata URI
    /// @param URI of the smart-contract
    function setContractURI(string calldata URI) external onlyOwner notLocked {
        _contractURI = URI;
    }
    
    /// Set the base URI for the tokens metadata
    /// @param URI for the base URI structure of each token
    function setBaseURI(string calldata URI) external onlyOwner notLocked {
        _tokenBaseURI = URI;
    }

    /// Smart-contract metadata
    /// @dev see https://docs.opensea.io/docs/contract-level-metadata
    function contractURI() public view returns (string memory) {
        return _contractURI;
    }
    
    /// Retrieve the token URI from an id
    /// @param tokenId as an int
    /// @dev see https://docs.soliditylang.org/en/v0.5.3/abi-spec.html#non-standard-packed-mode
    /// e.g: ipfs://bafybeic26wp7ck2bsjhjm5pcdigxqebnthqrmugsygxj5fov2r2qwhxyqu/1, for tokenId: 1
    function tokenURI(uint256 tokenId) public view override(ERC721) returns (string memory) {
        require(_exists(tokenId), "Cannot query non-existent token");
        return string(abi.encodePacked(_tokenBaseURI, tokenId.toString()));
    }
}